#Changjae Hanimport selectimport socketimport structimport argparseimport datetime as dtimport timefrom queue import Queueimport randomimport logging"""routing    1. find the destination of the packet """def routing(table_list, dest_addr, dest_port, loggingInfo):    src_hostname, got_src_port, dest_hostname, got_dest_port, priority, data_length = loggingInfo    for i in range(0,len(table_list)):        if (int(table_list[i][3]) == dest_port): #if matches found            print("Routing Success")            return i            logging.debug(f"No forwarding entry found. Src hostname: {src_hostname} Src port: {got_src_port} "              f"Dest hostname: {dest_hostname} Dest port: {got_dest_port} Time of loss: "              f"{dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]} Priority level {priority} Size of payload: {data_length}")    return False"""queueing    1. queue the packet in order of priorities    2. que[0] = First, que[1] = Second, que[2] = Third"""def queueing(que, priority, sender_data, req_data, loggingInfo):    src_hostname, got_src_port, dest_hostname, got_dest_port, priority, data_length = loggingInfo    if que[priority-1].full():        if not req_data:            logging.debug(f"Priority queue {priority} was full. Src hostname: {src_hostname} Src port: {got_src_port} "              f"Dest hostname: {dest_hostname} Dest port: {got_dest_port} Time of loss: "              f"{dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]} Priority level {priority} Size of payload: {data_length}")            return True                que[priority-1].put(sender_data)    print("Queueing Success")    return True    """delaying    1. delay packet if no packet is currently being delayed"""def delaying(delayed_packet, que, table_list, line, req_data):    if delayed_packet: #There is delay packet        if time.time()-delayed_packet[0][1] < int(table_list[line][6])/1000: #Not expire, Delay failed            return False        else:            print("Delay expires, ready to be sent")            return delayed_packet.pop(0)[0] #Expire, ready to be sent    #There is no delay packet        for i in range(3):        if not que[i].empty():            packet = que[i].get()            if req_data:                 return packet            packet_timestamp = [packet, time.time()]            delayed_packet.append(packet_timestamp)            print("Delay packet")            return False    #Queue is empty    return False"""sending    1. send packet to nexthop    2. randomly dropped by loss probability"""def sending(table_list, line, que, emulator_socket, req_data, packet, loggingInfo):    src_hostname, got_src_port, dest_hostname, got_dest_port, priority, data_length = loggingInfo    if not req_data:        #May drop the packet        rand = random.random()        loss_prob = int(table_list[line][7])/100        if(rand <= loss_prob):            logging.debug(f"loss event occurred. Src hostname: {src_hostname} Src port: {got_src_port} "              f"Dest hostname: {dest_hostname} Dest port: {got_dest_port} Time of loss: "              f"{dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]} Priority level {priority} Size of payload: {data_length}")            return False    #send the packet to the proper next hop    nexthop_ip_addr = socket.gethostbyname(table_list[packet[1]][4])    emulator_socket.sendto(packet[0], (nexthop_ip_addr, int(table_list[packet[1]][5])))    print("Successfully sent to:", table_list[packet[1]][4])        return True        """log    1. integrate all function    2. log event when packet dropped"""def log(emulator_port, que, table_list, log_name, delaying_packet):    #Create a sender socket for UDP transmission    emulator_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)        #Non-blocking mode    emulator_socket.setblocking(0)    emulator_ip_addr = socket.gethostbyname(socket.gethostname())    emulator_addr_port = (emulator_ip_addr, emulator_port)    #Bind the socket to the sender's address    emulator_socket.bind(emulator_addr_port)    #logging function    logging.basicConfig(filename=log_name, level=logging.DEBUG)        print("Emulator is waiting for messages..")            #When the emulator gets the packet from the sender or requester    while True:        readable, _, _ = select.select([emulator_socket], [], [], 0) #Non-blocking        if emulator_socket in readable:            try:                sender_data, sender_addr_port = emulator_socket.recvfrom(1024)            except socket.error:                continue            #Process received data            outer_header = sender_data[:17]            inner_header = sender_data[17:26]                        decoded_outer_header = struct.unpack("!B4sH4sHI", outer_header)            decoded_inner_header = struct.unpack("!cII", inner_header)                        priority, got_src_addr, got_src_port, got_dest_addr, got_dest_port, outer_length = decoded_outer_header            _,_,data_length = decoded_inner_header             dest_addr = socket.inet_ntoa(got_dest_addr)            dest_port = got_dest_port                        src_hostname,_,_ = socket.gethostbyaddr(socket.inet_ntoa(got_src_addr))            dest_hostname,_,_ = socket.gethostbyaddr(socket.inet_ntoa(got_dest_addr))            loggingInfo = (src_hostname, got_src_port, dest_hostname, got_dest_port, priority, data_length)	    	    #Table line as a result of routing                        line = routing(table_list, dest_addr, dest_port, loggingInfo)            if not (line+1):                continue                        sender_data = [sender_data, line]            req_data = False #Requester data            if decoded_inner_header[0] == b'R' or decoded_inner_header[0] == b'A':                 req_data = True            if decoded_inner_header[0] == b'E': #If End packet: hardcode to send to destination                 nexthop_ip_addr = socket.gethostbyname(table_list[sender_data[1]][4])                emulator_socket.sendto(sender_data[0], (nexthop_ip_addr, int(table_list[sender_data[1]][5])))                continue            queueing(que, priority, sender_data, req_data, loggingInfo)            	    #Packet after delay             delayed_packet = delaying(delaying_packet, que, table_list, line, req_data)            if not delayed_packet:                continue                        if not sending(table_list, line, que, emulator_socket, req_data, delayed_packet, loggingInfo):                continue    emulator_socket.close()def main():    parser = argparse.ArgumentParser(description="emulator data")    parser.add_argument('-p', type=int, metavar='port', help= 'requester port num')    parser.add_argument('-q', type=int, metavar='queue_size', help = 'size of three queues')    parser.add_argument('-f', metavar='filename', help= 'name of file containing static forwarding table')    parser.add_argument('-l', metavar='log', help= 'the name of log file')    args = parser.parse_args()    table_file = open(args.f, "r")        table_list = []    while True:        cur_line = table_file.readline()        if not cur_line: break        each_data = cur_line.split(" ")        each_data[-1] = each_data[-1].strip() #Remove each space in the end of cur_line        table_list.append(each_data)                delaying_packet = []    que = [Queue(maxsize=args.q) for _ in range(3)]        log(args.p, que, table_list, args.l, delaying_packet)            table_file.close()if __name__ == "__main__":    main()