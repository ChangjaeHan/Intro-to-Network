#Changjae Hanimport selectimport argparseimport socketimport osimport structimport datetime as dtimport timesender_buffer = {}"""Read_data    1. Create the sender socket    2. Read requested data by unpacking    3. Pass on to send_data"""def read_data(send_port, req_port, rate, seq_no, length, emulator_name, emulator_port, priority, timeout):        #Create a sender socket for UDP transmission    sender_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)    #Non-blocking mode    sender_socket.setblocking(0)    #Build IP_Address and Port of Sender    sender_ip_addr = socket.gethostbyname(socket.gethostname())    sender_addr_port = (sender_ip_addr, send_port)    #Bind the socket to the sender's address    sender_socket.bind(sender_addr_port)    print("Sender is waiting for messages..")    #Wait the sender gets the request from the requester    while True:                readable, _, _ = select.select([sender_socket], [], [], 0)  # Non-blocking check        if sender_socket in readable:            try:                data_received, _ = sender_socket.recvfrom(1024)            except socket.error:                continue                    outer_header = data_received[:17]            inner_header = data_received[17:26]            #Classify header and filename            decoded_outer_header = struct.unpack("!B4sH4sHI", outer_header)            decoded_inner_header = struct.unpack("!cII", inner_header)            filename = data_received[26:]                              if decoded_inner_header[0] == b'R':                 break           process_data(filename, rate, seq_no, length, decoded_outer_header, decoded_inner_header, sender_socket, emulator_name, emulator_port, priority, timeout,sender_buffer)"""Process_data    1. send window_size packet    2. if doesn't get ACK, retransmit 5 times, still doesn't get it, drop it """            def process_data(filename, rate, seq_no, length, decoded_outer_header, decoded_inner_header, sender_socket, emulator_name, emulator_port, priority, timeout, sender_buffer):        seq_no = 1        _, got_src_addr, got_src_port, got_dest_addr, got_dest_port, outer_length = decoded_outer_header        packet_type, _, window_size = decoded_inner_header                print("-----------------------------------------------------------------------------")        print("sender's print information:")                #Read file         try:            file = open(filename, "r")            file_size = os.path.getsize(filename)        #Fail to read file        except FileNotFoundError:            print("It doesn't contain such a file")            pass        #Succeed to read file, send the data to the requester        else:            retrans_num = 0            total_trans = 0            resend_buffer = []            cnt = 0            last_packet = False            while (file_size > 0): #Decided by max_length, may not send the data all at once                if file_size > length:                    data_length = length                else:                    data_length = file_size                    last_packet = True                payload = file.read(data_length)                file_size -= length                cnt += 1                                sender_buffer[seq_no] = payload                resend_buffer.append(seq_no)                #Pack and send the DATA packet to the requester                outer_data_header = struct.pack("!B4sH4sHI", priority, got_dest_addr, got_dest_port, got_src_addr, got_src_port, outer_length)                inner_data_header = struct.pack("!cII", b'D', socket.htonl(seq_no), data_length)                packet = outer_data_header + inner_data_header + payload.encode()                emulator_ip_addr = socket.gethostbyname(emulator_name)                sender_socket.sendto(packet, (emulator_ip_addr,emulator_port))                total_trans += 1                 print("DATA Packet")                print("send time:  ", dt.datetime.now(), sep='')                print("requester addr:  ",socket.inet_ntoa(got_src_addr) , ":", got_src_port, sep='')                print("Sequence num:  ", seq_no, sep='')                print("length:  ", data_length, sep='')                print("payload:  " + payload[0:4])                print("")                                      if cnt == window_size or last_packet: #Wait for ACKs                    print("-----End of Window, then Wait for ACKs...-----")                                        drop_cnt = 6                    trial = 6                    while trial > 0:                        start_time = time.time()                        while time.time() - start_time < timeout/1000:                            readable, _, _ = select.select([sender_socket], [], [], 0)                            if sender_socket in readable:                                try:                                    data_received, _ = sender_socket.recvfrom(1024)                                except socket.error:                                    continue                                inner_header = data_received[17:26]                                decoded_inner_header = struct.unpack("!cII", inner_header)                                packet_type, got_seq_no, _ = decoded_inner_header                                filename = data_received[26:]				#If sender gets ACK                                                                       if decoded_inner_header[0] == b'A':                                                 if socket.ntohl(got_seq_no) in sender_buffer:                                        print("!Got TRUE ACK PACKET for ", socket.ntohl(got_seq_no))                                        sender_buffer.pop(socket.ntohl(got_seq_no))                                        resend_buffer.remove(socket.ntohl(got_seq_no))                                        check_ACK = True                        if resend_buffer: #There are some packets that need to be resended                            print("It doesn't get ACK packet, then retransit seq", resend_buffer)                            #Try to retransit                                         for i in resend_buffer:                                payload = sender_buffer[i]                                outer_data_header = struct.pack("!B4sH4sHI", priority, got_dest_addr, got_dest_port, got_src_addr, got_src_port, outer_length)                                inner_data_header = struct.pack("!cII", b'D', socket.htonl(i), len(payload))                                packet = outer_data_header + inner_data_header + payload.encode()                                emulator_ip_addr = socket.gethostbyname(emulator_name)                                sender_socket.sendto(packet, (emulator_ip_addr,emulator_port))                                total_trans += 1                                retrans_num += 1                            drop_cnt -= 1                            trial -= 1                        else:                            break                    if not drop_cnt:                        print("Use all trials.. end up dropping packet for ", resend_buffer)                        resend_buffer = []                        sender_buffer = {}                    cnt = 0                seq_no += 1                time.sleep(1/rate) #Time delay by rate                                file.close()                                    #Send END PACKET            outer_data_header = struct.pack("!B4sH4sHI", priority, got_dest_addr, got_dest_port, got_src_addr, got_src_port, outer_length)            inner_data_header = struct.pack("!cII", b'E', socket.htonl(seq_no), 0)            packet = outer_data_header + inner_data_header            sender_socket.sendto(packet, (emulator_ip_addr,emulator_port))                        loss_rate = retrans_num/total_trans            print("Loss rate overall is:", loss_rate)            sender_socket.close()def main():        parser = argparse.ArgumentParser(description="sender data")    parser.add_argument('-p', type=int, metavar='port', help = 'sender port num')    parser.add_argument('-g', type=int, metavar='requester_port', help = 'requester port num')    parser.add_argument('-r', type=int, metavar='rate', help = 'packet rate per second')    parser.add_argument('-q', type=int, metavar='seq_no', help = 'sequence number')    parser.add_argument('-l', type=int, metavar='length', help = 'length of payload')        parser.add_argument('-f', metavar='f_hostname', help = 'host name of emulator')    parser.add_argument('-e', type=int, metavar='f_port', help = 'the port of emulator')    parser.add_argument('-i', type=int, metavar='priority', help = 'priority of sent packets')    parser.add_argument('-t', type=int, metavar='timeout', help = 'timeout for retransmission for lost packets ms')            args = parser.parse_args()    read_data(args.p, args.g, args.r, args.q, args.l, args.f, args.e, args.i, args.t)if __name__ == "__main__":	main()